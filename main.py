import argparse
import os
from pathlib import Path
from typing import Optional

import numpy as np
from sklearn.datasets import make_moons
from sklearn.neighbors import NearestNeighbors

CWD = Path.cwd()
INPUT_DIR = CWD / "test" / "input"
INPUT_DIR.mkdir(parents=True, exist_ok=True)

DEFAULT_N: int = 200
DEFAULT_EPS: float = 1300.0
DEFAULT_K: int = 5  # includes self
DEFAULT_THREADS: int = os.cpu_count() or 1  # Use all available CPU cores
DEFAULT_NOISE: float = 0.05
DEFAULT_OUT_KNN: Path = INPUT_DIR / "input.txt"
DEFAULT_OUT_GT: Path = INPUT_DIR / "gt.txt"
DEFAULT_OUT_POINTS: Path = INPUT_DIR / "points.txt"
DEFAULT_RANDOM_STATE: int = 42


def make_knn_graph(X: np.ndarray, k: int) -> tuple[np.ndarray, np.ndarray]:
    """Build a k-NN graph over X.

    Args:
        X: Array of shape (n_samples, n_features).
        k: Number of neighbors to return (includes self).

    Returns:
        distances: Array of shape (n_samples, k) with Euclidean distances.
        indices: Array of shape (n_samples, k) with neighbor indices.
    """
    n_samples = X.shape[0]
    k = min(k, n_samples)
    nn = NearestNeighbors(n_neighbors=k, algorithm="auto", metric="euclidean")
    nn.fit(X)
    distances, indices = nn.kneighbors(X)
    return distances, indices


def write_knn_file(path: Path, distances: np.ndarray, indices: np.ndarray) -> None:
    """Write k-NN graph as ASCII.

    Each line: `id d0 id0 d1 id1 ...`

    Args:
        path: Output file path.
        distances: Array of shape (n_samples, k).
        indices: Array of shape (n_samples, k).
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    n = distances.shape[0]
    with path.open("w") as f:
        for i in range(n):
            parts = [str(i)]
            for d, idx in zip(distances[i], indices[i]):
                parts.append(f"{d:.6f}")
                parts.append(str(int(idx)))
            f.write(" ".join(parts) + "\n")


def write_gt_file(path: Path, labels: np.ndarray) -> None:
    """Write one integer label per line.

    Args:
        path: Output file path.
        labels: Array of shape (n_samples,) with ground-truth labels.
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w") as f:
        for lab in labels:
            f.write(f"{int(lab)}\n")


def write_points_file(path: Path, X: np.ndarray) -> None:
    """Write point ID and coordinates per line.

    Each line: `id x0 x1 ...`
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w") as f:
        for coords in X:
            coord_str = " ".join(f"{c:.6f}" for c in coords)
            f.write(coord_str + "\n")


def parse_args() -> argparse.Namespace:
    """Parse CLI arguments."""
    p = argparse.ArgumentParser(
        description="Generate toy kNN graph and ground-truth from make_moons.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    p.add_argument("--n", type=int, default=DEFAULT_N, help="Number of samples.")
    p.add_argument(
        "--eps", type=float, default=DEFAULT_EPS, help="Epsilon (for knndbscan)."
    )
    p.add_argument(
        "--k", type=int, default=DEFAULT_K, help="Neighbors to store (incl. self)."
    )
    p.add_argument(
        "--threads",
        type=int,
        default=DEFAULT_THREADS,
        help="Number of threads (for knndbscan).",
    )
    p.add_argument("--noise", type=float, default=DEFAULT_NOISE, help="Noise level.")
    p.add_argument(
        "--out-knn",
        type=Path,
        default=DEFAULT_OUT_KNN,
        help="Path to output kNN graph file.",
    )
    p.add_argument(
        "--out-gt",
        type=Path,
        default=DEFAULT_OUT_GT,
        help="Path to output ground-truth labels file.",
    )
    p.add_argument(
        "--out-points",
        type=Path,
        default=DEFAULT_OUT_POINTS,
        help="Path to output points file.",
    )
    p.add_argument(
        "--random-state", type=int, default=DEFAULT_RANDOM_STATE, help="Random seed."
    )
    return p.parse_args()


def create_run_script(
    out_dir: Path,
    exe: Path,
    n: int,
    eps: float,
    minPts: int,
    graph_k: Optional[int],
    threads: int,
    knn_file: Path,
    out_labels: Path,
) -> Path:
    """Write a shell script that runs the test `knndbscan` binary with sensible defaults.

    The script is written to ``out_dir/run_knndbscan.sh`` and made executable.

    Returns the Path to the created script.
    """
    exe = CWD / "test" / "knndbscan"
    if not exe.exists():
        raise FileNotFoundError(f"knndbscan executable not found at: {exe}")

    graph_k = graph_k if graph_k is not None else minPts
    out_dir.mkdir(parents=True, exist_ok=True)
    script_path = out_dir / "run_test_knndbscan.sh"
    content = f"""#!/usr/bin/env bash
# Generated by main.py - runs knndbscan on the test kNN graph produced by this script
set -euo pipefail

EXE=\"{exe}\"

"$EXE" -n {n} -e {eps} -m {minPts} -i \"{knn_file}\" -k {graph_k} -o \"{out_labels}\" -t {threads}
"""
    script_path.write_text(content)
    # make executable
    script_path.chmod(0o755)
    return script_path


def main() -> None:
    """Entry point."""
    args = parse_args()

    print(
        f"Generating make_moons: n={args.n}, noise={args.noise}, seed={args.random_state}"
    )
    X, y = make_moons(
        n_samples=args.n, noise=args.noise, random_state=args.random_state
    )

    # Write all outputs
    distances, indices = make_knn_graph(X, args.k)
    write_knn_file(args.out_knn, distances, indices)
    write_gt_file(args.out_gt, y)
    write_points_file(args.out_points, X)

    print(f"Wrote kNN graph to: {args.out_knn}")
    print(f"Wrote ground-truth labels to: {args.out_gt}")
    print(f"Wrote points file to: {args.out_points}")

    # Generate run script
    out_dir = Path(args.out_knn).parent
    script = create_run_script(
        out_dir=out_dir,
        exe=out_dir / "knndbscan",
        n=args.n,
        eps=args.eps,
        minPts=args.k,
        graph_k=args.k,
        threads=args.threads,
        knn_file=Path(args.out_knn),
        out_labels=out_dir / "labels.txt",
    )
    print(f"Wrote run script: {script}")


if __name__ == "__main__":
    main()
